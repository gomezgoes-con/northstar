<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NorthStar - Query Analyzer for StarRocks</title>
  
  <!-- Google Font: JetBrains Mono for that data/code feel -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
  
  <style>
    /* ========================================
       CSS Variables - Our color palette
       Using a dark theme with teal accents
       ======================================== */
    :root {
      --bg-primary: #0d1117;      /* Main background - deep dark blue */
      --bg-secondary: #161b22;    /* Cards/panels background */
      --bg-tertiary: #21262d;     /* Hover states, borders */
      --text-primary: #e6edf3;    /* Main text - off-white */
      --text-secondary: #8b949e;  /* Muted text */
      --accent: #00d4aa;          /* Teal accent - our brand color */
      --accent-dim: #00d4aa33;    /* Accent with transparency */
      --border: #30363d;          /* Subtle borders */
      --success: #3fb950;         /* Green for good metrics */
      --warning: #d29922;         /* Yellow/orange for warnings */
      --danger: #f85149;          /* Red for issues */
    }

    /* ========================================
       Base Styles
       ======================================== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'JetBrains Mono', monospace;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.6;
    }

    /* ========================================
       Header
       ======================================== */
    header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      padding: 1rem 2rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .logo-img {
      height: 40px;
      width: auto;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--accent);
    }

    header h1 {
      font-size: 0.9rem;
      font-weight: 400;
      color: var(--text-secondary);
    }

    /* ========================================
       Main Container
       ======================================== */
    main {
      max-width: 1800px;
      margin: 0 auto;
      padding: 2rem;
    }

    /* ========================================
       Drop Zone - Where users drag JSON files
       ======================================== */
    .drop-zone {
      border: 2px dashed var(--border);
      border-radius: 12px;
      padding: 3rem;
      text-align: center;
      transition: all 0.3s ease;
      cursor: pointer;
      background: var(--bg-secondary);
    }

    .drop-zone:hover,
    .drop-zone.drag-over {
      border-color: var(--accent);
      background: var(--accent-dim);
    }

    .drop-zone-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
    }

    .drop-zone h2 {
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      color: var(--text-primary);
    }

    .drop-zone p {
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    .drop-zone input[type="file"] {
      display: none;
    }

    /* ========================================
       Dashboard Container (hidden until file loads)
       ======================================== */
    .dashboard {
      display: none;
    }

    .dashboard.visible {
      display: block;
    }

    /* ========================================
       Query Info Section
       ======================================== */
    .query-info {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      border: 1px solid var(--border);
    }

    .query-info h2 {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-secondary);
      margin-bottom: 1rem;
    }

    .query-meta {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }

    .meta-item {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .meta-item label {
      font-size: 0.7rem;
      text-transform: uppercase;
      color: var(--text-secondary);
    }

    .meta-item span {
      font-size: 0.9rem;
      color: var(--text-primary);
    }

    /* ========================================
       Summary Cards - Organized in Sections
       ======================================== */
    .cards-container {
      display: grid;
      grid-template-columns: 1fr 2fr;
      grid-template-rows: auto auto;
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .cards-section {
      background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(22, 27, 34, 0.8) 100%);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.25rem 1.5rem 1.5rem;
      position: relative;
      overflow: hidden;
    }

    /* Memory section spans left column, both rows */
    .cards-section#memoryCards {
      grid-column: 1;
      grid-row: 1 / 3;
      border-left: 3px solid var(--warning);
    }

    /* Time section - top right */
    .cards-section#timeCards {
      grid-column: 2;
      grid-row: 1;
      border-left: 3px solid var(--success);
    }

    /* Scan section - bottom right */
    .cards-section#scanCards {
      grid-column: 2;
      grid-row: 2;
      border-left: 3px solid var(--accent);
    }

    .section-title {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--text-secondary);
      margin-bottom: 1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .section-title::before {
      content: '';
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
    }

    #memoryCards .section-title { color: var(--warning); }
    #timeCards .section-title { color: var(--success); }
    #scanCards .section-title { color: var(--accent); }

    .summary-cards {
      display: grid;
      gap: 0.75rem;
    }

    #memoryCards .summary-cards {
      grid-template-columns: 1fr;
    }

    #timeCards .summary-cards,
    #scanCards .summary-cards {
      grid-template-columns: repeat(4, 1fr);
    }

    .card {
      background: rgba(33, 38, 45, 0.6);
      border: 1px solid rgba(48, 54, 61, 0.6);
      border-radius: 8px;
      padding: 1rem 1.25rem;
      transition: all 0.2s ease;
    }

    .card:hover {
      background: rgba(33, 38, 45, 0.9);
      border-color: var(--border);
      transform: translateY(-1px);
    }

    .card-label {
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }

    .card-value {
      font-size: 1.4rem;
      font-weight: 600;
      color: var(--accent);
      line-height: 1.2;
    }

    .card-value.bytes {
      color: var(--warning);
    }

    .card-value.time {
      color: var(--success);
    }

    .card-value.rows {
      color: #a5d6ff;
    }

    /* Responsive: stack on smaller screens */
    @media (max-width: 1200px) {
      .cards-container {
        grid-template-columns: 1fr;
        grid-template-rows: auto;
      }
      
      .cards-section#memoryCards,
      .cards-section#timeCards,
      .cards-section#scanCards {
        grid-column: 1;
        grid-row: auto;
      }
      
      #memoryCards .summary-cards {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* ========================================
       Data Table Section
       ======================================== */
    .table-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
    }

    .table-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .table-header h2 {
      font-size: 1rem;
      font-weight: 600;
    }

    .table-container {
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }

    th, td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid var(--border);
      white-space: nowrap;
    }

    th {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-weight: 500;
      text-transform: uppercase;
      font-size: 0.7rem;
      letter-spacing: 0.05em;
      position: sticky;
      top: 0;
      cursor: pointer;
      user-select: none;
    }

    th:hover {
      color: var(--accent);
    }

    th.sorted-asc::after {
      content: ' ‚ñ≤';
      color: var(--accent);
    }

    th.sorted-desc::after {
      content: ' ‚ñº';
      color: var(--accent);
    }

    /* Group Header Row - the top row with category names */
    tr.group-header-row th {
      background: var(--bg-secondary);
      color: var(--text-secondary);
      font-weight: 500;
      font-size: 0.7rem;
      text-align: center;
      border-bottom: 1px solid var(--border);
      cursor: default;
      padding: 0.4rem 1rem;
      letter-spacing: 0.05em;
    }

    tr.group-header-row th:hover {
      color: var(--text-secondary); /* Don't change on hover */
    }

    tr.group-header-row th.group-spacer {
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border);
    }

    /* Add subtle left border to first column of each group */
    th.group-start,
    td.group-start {
      border-left: 1px solid var(--text-secondary);
    }

    tr:hover {
      background: var(--bg-tertiary);
    }

    td {
      color: var(--text-primary);
    }

    /* Special styling for certain columns */
    td.table-name {
      color: var(--accent);
      font-weight: 500;
    }

    td.predicate {
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-secondary);
    }

    td.number {
      font-variant-numeric: tabular-nums;
      text-align: right;
    }

    td.bytes {
      color: var(--warning);
    }

    td.time {
      color: var(--success);
    }

    td.rows {
      color: #a5d6ff;
    }

    /* ========================================
       Utility Classes
       ======================================== */
    .hidden {
      display: none !important;
    }

    .text-muted {
      color: var(--text-secondary);
    }

    /* ========================================
       Tab Navigation
       ======================================== */
    .tab-nav {
      display: flex;
      gap: 0;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      padding: 0 2rem;
    }

    .tab-btn {
      padding: 1rem 1.5rem;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-family: inherit;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s ease;
    }

    .tab-btn:hover {
      color: var(--text-primary);
      background: rgba(255,255,255,0.03);
    }

    .tab-btn.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .tab-panel {
      display: none;
    }

    .tab-panel.active {
      display: block;
    }

    /* ========================================
       Comparison View
       ======================================== */
    .compare-dropzones {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .compare-drop {
      border: 2px dashed var(--border);
      border-radius: 12px;
      padding: 2rem;
      text-align: center;
      transition: all 0.3s ease;
      cursor: pointer;
      background: var(--bg-secondary);
      position: relative;
    }

    .compare-drop:hover,
    .compare-drop.drag-over {
      border-color: var(--accent);
      background: var(--accent-dim);
    }

    .compare-drop.loaded {
      border-color: var(--success);
      border-style: solid;
    }

    .compare-drop h3 {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 0.5rem;
    }

    .compare-drop.baseline h3 { color: var(--warning); }
    .compare-drop.optimized h3 { color: var(--success); }

    .compare-drop p {
      color: var(--text-secondary);
      font-size: 0.8rem;
    }

    .compare-drop .loaded-info {
      color: var(--text-primary);
      font-size: 0.85rem;
    }

    .compare-drop input[type="file"] {
      display: none;
    }

    /* Comparison Results */
    .compare-results {
      display: none;
    }

    .compare-results.visible {
      display: block;
    }

    .compare-header {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .compare-query-info {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem 1.5rem;
    }

    .compare-query-info.baseline {
      border-left: 3px solid var(--warning);
    }

    .compare-query-info.optimized {
      border-left: 3px solid var(--success);
    }

    .compare-query-info h4 {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 0.75rem;
    }

    .compare-query-info.baseline h4 { color: var(--warning); }
    .compare-query-info.optimized h4 { color: var(--success); }

    .compare-query-info .meta-row {
      display: flex;
      gap: 2rem;
      font-size: 0.8rem;
    }

    .compare-query-info .meta-row span {
      color: var(--text-secondary);
    }

    .compare-query-info .meta-row strong {
      color: var(--text-primary);
      margin-left: 0.5rem;
    }

    /* Comparison Cards */
    .compare-cards-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.25rem 1.5rem 1.5rem;
      margin-bottom: 1.5rem;
    }

    .compare-cards-section h3 {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-secondary);
      margin-bottom: 1rem;
    }

    .compare-cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }

    .compare-card {
      background: rgba(33, 38, 45, 0.6);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
    }

    .compare-card-label {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
      margin-bottom: 0.75rem;
    }

    .compare-card-values {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 1rem;
    }

    .compare-value {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .compare-value-label {
      font-size: 0.55rem;
      text-transform: uppercase;
      color: var(--text-secondary);
    }

    .compare-value-num {
      font-size: 1.1rem;
      font-weight: 600;
    }

    .compare-value-num.baseline { color: var(--warning); }
    .compare-value-num.optimized { color: var(--success); }

    .compare-change {
      text-align: right;
    }

    .compare-change-pct {
      font-size: 1rem;
      font-weight: 700;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
    }

    .compare-change-pct.improved {
      color: var(--success);
      background: rgba(63, 185, 80, 0.15);
    }

    .compare-change-pct.regressed {
      color: var(--danger);
      background: rgba(248, 81, 73, 0.15);
    }

    .compare-change-pct.neutral {
      color: var(--text-secondary);
      background: rgba(139, 148, 158, 0.15);
    }

    .compare-change-label {
      font-size: 0.55rem;
      color: var(--text-secondary);
      margin-top: 0.25rem;
    }
  </style>
</head>
<body>
  <!-- ========================================
       Header Section
       ======================================== -->
  <header>
    <img src="northstar.png" alt="NorthStar Logo" class="logo-img">
    <div class="logo">NorthStar</div>
    <h1>Query Analyzer for StarRocks</h1>
  </header>

  <!-- ========================================
       Tab Navigation
       ======================================== -->
  <nav class="tab-nav">
    <button class="tab-btn active" data-tab="single">Single Query</button>
    <button class="tab-btn" data-tab="compare">Query Comparison</button>
  </nav>

  <!-- ========================================
       Main Content
       ======================================== -->
  <main>
    <!-- ====== SINGLE QUERY TAB ====== -->
    <div class="tab-panel active" id="tab-single">
      <!-- Drop Zone: Visible initially for file upload -->
      <div class="drop-zone" id="dropZone">
      <div class="drop-zone-icon">üìÅ</div>
      <h2>Drop your query profile JSON here</h2>
      <p>or click to browse files</p>
      <input type="file" id="fileInput" accept=".json">
    </div>

    <!-- Dashboard: Hidden until a file is loaded -->
    <div class="dashboard" id="dashboard">
      
      <!-- Query Info Panel -->
      <section class="query-info">
        <h2>Query Information</h2>
        <div class="query-meta" id="queryMeta">
          <!-- Populated by JavaScript -->
        </div>
      </section>

      <!-- Summary Cards - Organized in Sections -->
      <div class="cards-container">
        <section class="cards-section" id="memoryCards">
          <h3 class="section-title">Memory</h3>
          <div class="summary-cards">
            <!-- Populated by JavaScript -->
          </div>
        </section>
        
        <section class="cards-section" id="timeCards">
          <h3 class="section-title">Time</h3>
          <div class="summary-cards">
            <!-- Populated by JavaScript -->
          </div>
        </section>
        
        <section class="cards-section" id="scanCards">
          <h3 class="section-title">Scan Metrics</h3>
          <div class="summary-cards">
            <!-- Populated by JavaScript -->
          </div>
        </section>
      </div>

      <!-- CONNECTOR_SCAN Table -->
      <section class="table-section">
        <div class="table-header">
          <h2>üîç CONNECTOR_SCAN Operators</h2>
        </div>
        <div class="table-container">
          <table id="scanTable">
            <thead id="tableHead">
              <!-- Populated by JavaScript: two rows (group headers + column headers) -->
            </thead>
            <tbody id="tableBody">
              <!-- Populated by JavaScript -->
            </tbody>
          </table>
        </div>
      </section>
    </div>
    </div> <!-- End of tab-single -->

    <!-- ====== QUERY COMPARISON TAB ====== -->
    <div class="tab-panel" id="tab-compare">
      <!-- Two Drop Zones for Comparison -->
      <div class="compare-dropzones">
        <div class="compare-drop baseline" id="compareDropBaseline">
          <h3>üìä Baseline Query</h3>
          <p>Drop the original query profile</p>
          <input type="file" id="compareFileBaseline" accept=".json">
        </div>
        <div class="compare-drop optimized" id="compareDropOptimized">
          <h3>üöÄ Optimized Query</h3>
          <p>Drop the optimized query profile</p>
          <input type="file" id="compareFileOptimized" accept=".json">
        </div>
      </div>

      <!-- Comparison Results (hidden until both files loaded) -->
      <div class="compare-results" id="compareResults">
        <!-- Query Info Headers -->
        <div class="compare-header">
          <div class="compare-query-info baseline">
            <h4>üìä Baseline</h4>
            <div class="meta-row" id="compareMetaBaseline"></div>
          </div>
          <div class="compare-query-info optimized">
            <h4>üöÄ Optimized</h4>
            <div class="meta-row" id="compareMetaOptimized"></div>
          </div>
        </div>

        <!-- Memory Comparison -->
        <div class="compare-cards-section">
          <h3>Memory Comparison</h3>
          <div class="compare-cards-grid" id="compareMemoryCards"></div>
        </div>

        <!-- Time Comparison -->
        <div class="compare-cards-section">
          <h3>Time Comparison</h3>
          <div class="compare-cards-grid" id="compareTimeCards"></div>
        </div>

        <!-- Scan Metrics Comparison -->
        <div class="compare-cards-section">
          <h3>Scan Metrics Comparison</h3>
          <div class="compare-cards-grid" id="compareScanCards"></div>
        </div>
      </div>
    </div>
  </main>

  <!-- ========================================
       JavaScript
       ======================================== -->
  <script>
    // ========================================
    // STEP 2: File Loading & JSON Parsing
    // ========================================

    // Get references to our DOM elements
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const dashboard = document.getElementById('dashboard');

    // -----------------------------------------
    // Drag and Drop Event Handlers
    // -----------------------------------------
    
    // When user drags a file over the drop zone
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault(); // Prevent browser from opening the file
      dropZone.classList.add('drag-over'); // Add visual feedback
    });

    // When user's drag leaves the drop zone
    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('drag-over');
    });

    // When user drops a file
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('drag-over');
      
      // Get the dropped file (we only care about the first one)
      const file = e.dataTransfer.files[0];
      if (file && file.name.endsWith('.json')) {
        loadFile(file);
      } else {
        alert('Please drop a JSON file');
      }
    });

    // Click on drop zone opens file picker
    dropZone.addEventListener('click', () => {
      fileInput.click();
    });

    // When user selects a file via the file picker
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        loadFile(file);
      }
    });

    // -----------------------------------------
    // File Loading Function
    // -----------------------------------------
    function loadFile(file) {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        try {
          // Parse the JSON content
          const json = JSON.parse(e.target.result);
          console.log('Loaded JSON:', json);
          
          // Process the data (Step 3 will expand this)
          processQueryProfile(json);
          
        } catch (error) {
          console.error('Error parsing JSON:', error);
          alert('Error parsing JSON file: ' + error.message);
        }
      };
      
      reader.readAsText(file);
    }

    // -----------------------------------------
    // JSON Processing - Extract CONNECTOR_SCAN
    // -----------------------------------------
    function processQueryProfile(json) {
      // The structure is: Query > Execution > Fragment N > Pipeline (id=N) > CONNECTOR_SCAN
      
      const query = json.Query;
      if (!query) {
        alert('Invalid query profile format: missing "Query" object');
        return;
      }

      // Extract basic query info from Summary
      const summary = query.Summary || {};
      const execution = query.Execution || {};

      // Find all CONNECTOR_SCAN operators by recursively searching
      const connectorScans = findConnectorScans(execution);
      
      console.log(`Found ${connectorScans.length} CONNECTOR_SCAN operators`);
      console.log('CONNECTOR_SCAN data:', connectorScans);

      // Now render the dashboard (Step 3 will implement this)
      renderDashboard(summary, execution, connectorScans);
    }

    // -----------------------------------------
    // Recursive function to find CONNECTOR_SCAN
    // -----------------------------------------
    function findConnectorScans(obj, path = '') {
      const results = [];
      
      // Iterate through all keys in the object
      for (const key in obj) {
        const value = obj[key];
        
        // Check if this key is a CONNECTOR_SCAN operator
        if (key.startsWith('CONNECTOR_SCAN')) {
          // Extract the plan_node_id from the key, e.g., "CONNECTOR_SCAN (plan_node_id=66)"
          const match = key.match(/plan_node_id=(\d+)/);
          const planNodeId = match ? match[1] : 'unknown';
          
          results.push({
            id: planNodeId,
            path: path + ' > ' + key,
            commonMetrics: value.CommonMetrics || {},
            uniqueMetrics: value.UniqueMetrics || {}
          });
        }
        
        // If the value is an object, search recursively
        if (value && typeof value === 'object' && !Array.isArray(value)) {
          const nested = findConnectorScans(value, path ? `${path} > ${key}` : key);
          results.push(...nested);
        }
      }
      
      return results;
    }

    // ========================================
    // STEP 3: Render the Dashboard
    // ========================================

    // Define which metrics we want to display (from user requirements)
    // Columns are grouped - columns with the same 'group' value will share a header
    // group: null means no group header (standalone column)
    const METRICS_CONFIG = [
      // === General Info (no group) ===
      { key: 'Table',                           label: 'Table',              source: 'unique', type: 'string',    group: null },
      { key: 'Predicates',                      label: 'Predicates',         source: 'unique', type: 'predicate', group: null },
      
      // === Timing Metrics (no group) ===
      { key: 'PullRowNum',                      label: 'Pull Rows',          source: 'common', type: 'rows',      group: null },
      { key: 'JoinRuntimeFilterInputRows',      label: 'RF Input',           source: 'common', type: 'rows',      group: null },
      { key: 'JoinRuntimeFilterOutputRows',     label: 'RF Output',          source: 'common', type: 'rows',      group: null },
      { key: 'BytesRead',                       label: 'Bytes Read',         source: 'unique', type: 'bytes',     group: null },
      { key: 'OperatorTotalTime',               label: 'Operator Time',      source: 'common', type: 'time',      group: 'Run Time' },
      { key: 'ScanTime',                        label: 'Scan Time',          source: 'unique', type: 'time',      group: 'Run Time' },
      { key: 'IOTaskExecTime',                  label: 'IO Exec',            source: 'unique', type: 'time',      group: 'Scan Time' },
      { key: 'IOTaskWaitTime',                  label: 'IO Wait',            source: 'unique', type: 'time',      group: 'Scan Time' },
      { key: 'SegmentInit',                     label: 'Seg Init',           source: 'unique', type: 'time',      group: 'Scan Time' },
      { key: 'SegmentRead',                     label: 'Seg Read',           source: 'unique', type: 'time',      group: 'Scan Time' },
      
      // === Row Metrics (no group) ===
      { key: 'RowsRead',                        label: 'Rows Read',          source: 'unique', type: 'rows',      group: 'Pred Filters' },
      { key: 'PredFilterRows',                  label: 'Pred Filter',        source: 'unique', type: 'rows',      group: 'Pred Filters' },
      { key: 'LateMaterializeRows',             label: 'Late Mat',           source: 'unique', type: 'rows',      group: 'Pred Filters' },
      { key: 'RawRowsRead',                     label: 'Raw Rows Read',      source: 'unique', type: 'rows',      group: 'Pred Filters' },
            
      // === Index Filters (GROUPED) ===
      { key: 'DelVecFilterRows',                label: 'Del Vec',            source: 'unique', type: 'rows',      group: 'Index Filters' },
      { key: 'ZoneMapIndexFilterRows',          label: 'Zone Map',           source: 'unique', type: 'rows',      group: 'Index Filters' },
      { key: 'SegmentZoneMapFilterRows',        label: 'Seg Zone Map',       source: 'unique', type: 'rows',      group: 'Index Filters' },
      { key: 'BloomFilterFilterRows',           label: 'Bloom',              source: 'unique', type: 'rows',      group: 'Index Filters' },

      // === Short Key Filtering (GROUPED) ===
      { key: 'RemainingRowsAfterShortKeyFilter',label: 'Rows After ShortKey',source: 'unique', type: 'rows',      group: 'Short Key' },
      { key: 'ShortKeyFilterRows',              label: 'ShortKey Filter',    source: 'unique', type: 'rows',      group: 'Short Key' },

      // === Scan Structure (GROUPED) ===
      { key: 'TabletCount',                     label: 'Tablets',            source: 'unique', type: 'number',    group: 'Scan Structure' },
      { key: 'RowsetsReadCount',                label: 'Rowsets',            source: 'unique', type: 'number',    group: 'Scan Structure' },
      { key: 'SegmentsReadCount',               label: 'Segments',           source: 'unique', type: 'number',    group: 'Scan Structure' },
      { key: 'PagesCountTotal',                 label: 'Pages',              source: 'unique', type: 'number',    group: 'Scan Structure' },
    ];

    // Store data globally for sorting
    let currentData = [];

    function renderDashboard(summary, execution, connectorScans) {
      // Hide drop zone, show dashboard
      dropZone.classList.add('hidden');
      dashboard.classList.add('visible');

      // Store for sorting
      currentData = connectorScans;

      // 1. Render Query Metadata
      renderQueryMeta(summary);

      // 2. Render Summary Cards
      renderSummaryCards(connectorScans, execution);

      // 3. Render the Table
      renderTable(connectorScans);
    }

    // -----------------------------------------
    // Render Query Metadata Section
    // -----------------------------------------
    function renderQueryMeta(summary) {
      const container = document.getElementById('queryMeta');
      
      // Define which fields to show
      const fields = [
        { label: 'Query ID', key: 'Query ID' },
        { label: 'Start Time', key: 'Start Time' },
        { label: 'Duration', key: 'Total' },
        { label: 'State', key: 'Query State' },
        { label: 'User', key: 'User' },
        { label: 'Database', key: 'Default Db' },
        { label: 'Warehouse', key: 'Warehouse' },
      ];

      container.innerHTML = fields.map(f => `
        <div class="meta-item">
          <label>${f.label}</label>
          <span>${summary[f.key] || 'N/A'}</span>
        </div>
      `).join('');
    }

    // -----------------------------------------
    // Render Summary Cards (Organized in Sections)
    // -----------------------------------------
    function renderSummaryCards(scans, execution) {
      // Calculate totals from CONNECTOR_SCAN operators
      const totalScans = scans.length;
      const totalBytesRead = sumMetric(scans, 'BytesRead', 'unique');
      const totalRowsRead = sumMetric(scans, 'RowsRead', 'unique');
      const totalRawRows = sumMetric(scans, 'RawRowsRead', 'unique');

      // Get execution-level metrics directly from the Execution object
      const allocatedMemory = execution.QueryAllocatedMemoryUsage || 'N/A';
      const sumMemory = execution.QuerySumMemoryUsage || 'N/A';
      const cpuTime = execution.QueryCumulativeCpuTime || 'N/A';
      const scanTime = execution.QueryCumulativeScanTime || 'N/A';
      const operatorTime = execution.QueryCumulativeOperatorTime || 'N/A';
      const networkTime = execution.QueryCumulativeNetworkTime || 'N/A';

      // Helper to render cards
      const renderCards = (cards) => cards.map(c => `
        <div class="card">
          <div class="card-label">${c.label}</div>
          <div class="card-value ${c.type}">${c.value}</div>
        </div>
      `).join('');

      // Memory Section
      const memoryCards = [
        { label: 'Allocated Memory', value: allocatedMemory, type: 'bytes' },
        { label: 'Sum Memory Usage', value: sumMemory, type: 'bytes' },
      ];
      document.querySelector('#memoryCards .summary-cards').innerHTML = renderCards(memoryCards);

      // Time Section
      const timeCards = [
        { label: 'CPU Time', value: cpuTime, type: 'time' },
        { label: 'Scan Time', value: scanTime, type: 'time' },
        { label: 'Operator Time', value: operatorTime, type: 'time' },
        { label: 'Network Time', value: networkTime, type: 'time' },
      ];
      document.querySelector('#timeCards .summary-cards').innerHTML = renderCards(timeCards);

      // Scan Metrics Section
      const scanMetricCards = [
        { label: 'Connector Scan Operators', value: totalScans, type: 'number' },
        { label: 'Total Bytes Read', value: formatBytes(totalBytesRead), type: 'bytes' },
        { label: 'Total Rows Scanned', value: formatNumber(totalRawRows), type: 'rows' },
        { label: 'Total Rows Read', value: formatNumber(totalRowsRead), type: 'rows' },
      ];
      document.querySelector('#scanCards .summary-cards').innerHTML = renderCards(scanMetricCards);
    }

    // -----------------------------------------
    // Render Data Table with Grouped Headers
    // -----------------------------------------
    function renderTable(scans) {
      const thead = document.getElementById('tableHead');
      const tbody = document.getElementById('tableBody');

      // Clear existing content
      thead.innerHTML = '';

      // =============================================
      // ROW 1: Group Headers (spans multiple columns)
      // =============================================
      const groupHeaderRow = document.createElement('tr');
      groupHeaderRow.className = 'group-header-row';
      
      let currentGroup = null;
      let colspan = 0;
      let groupCells = [];

      // Track which columns start a new group (for border styling)
      const groupStartIndices = new Set();

      METRICS_CONFIG.forEach((col, idx) => {
        if (col.group !== currentGroup) {
          // Save the previous group if it existed
          if (colspan > 0) {
            groupCells.push({ group: currentGroup, colspan });
          }
          // Track the start of a new group
          if (col.group !== null) {
            groupStartIndices.add(idx);
          }
          currentGroup = col.group;
          colspan = 1;
        } else {
          colspan++;
        }
      });
      // Don't forget the last group
      if (colspan > 0) {
        groupCells.push({ group: currentGroup, colspan });
      }

      // Build the group header row
      groupCells.forEach(cell => {
        const th = document.createElement('th');
        th.colSpan = cell.colspan;
        if (cell.group === null) {
          // No group - just a spacer
          th.className = 'group-spacer';
          th.textContent = '';
        } else {
          th.textContent = cell.group;
        }
        groupHeaderRow.appendChild(th);
      });

      // =============================================
      // ROW 2: Individual Column Headers (sortable)
      // =============================================
      const columnHeaderRow = document.createElement('tr');
      
      METRICS_CONFIG.forEach((col, idx) => {
        const th = document.createElement('th');
        th.dataset.col = idx;
        th.dataset.key = col.key;
        th.textContent = col.label;
        
        // Add group-start class for left border
        if (groupStartIndices.has(idx)) {
          th.classList.add('group-start');
        }
        
        // Add click handler for sorting
        th.addEventListener('click', () => sortTable(th));
        
        columnHeaderRow.appendChild(th);
      });

      // Append both rows to thead
      thead.appendChild(groupHeaderRow);
      thead.appendChild(columnHeaderRow);

      // Store group start indices for body rows
      window.groupStartIndices = groupStartIndices;

      // Build body rows
      renderTableBody(scans);
    }

    function renderTableBody(scans) {
      const tbody = document.getElementById('tableBody');
      const groupStartIndices = window.groupStartIndices || new Set();
      
      tbody.innerHTML = scans.map(scan => {
        const cells = METRICS_CONFIG.map((col, idx) => {
          // Get value from either commonMetrics or uniqueMetrics
          const source = col.source === 'common' ? scan.commonMetrics : scan.uniqueMetrics;
          const value = source[col.key];
          
          // Apply styling based on type
          let displayValue = value ?? '-';
          let classNames = [];
          
          // Add group-start class for left border
          if (groupStartIndices.has(idx)) {
            classNames.push('group-start');
          }
          
          switch (col.type) {
            case 'string':
              classNames.push('table-name');
              break;
            case 'predicate':
              classNames.push('predicate');
              // Truncate long predicates
              if (displayValue.length > 50) {
                displayValue = displayValue.substring(0, 50) + '...';
              }
              break;
            case 'bytes':
              classNames.push('number', 'bytes');
              break;
            case 'time':
              classNames.push('number', 'time');
              break;
            case 'rows':
              classNames.push('number', 'rows');
              break;
            case 'number':
              classNames.push('number');
              break;
          }
          
          return `<td class="${classNames.join(' ')}" title="${value || ''}">${displayValue}</td>`;
        }).join('');
        
        return `<tr>${cells}</tr>`;
      }).join('');
    }

    // -----------------------------------------
    // Table Sorting
    // -----------------------------------------
    let sortColumn = null;
    let sortDirection = 'asc';

    function sortTable(th) {
      const key = th.dataset.key;
      const colIndex = parseInt(th.dataset.col);
      const config = METRICS_CONFIG[colIndex];
      
      // Toggle direction if same column
      if (sortColumn === key) {
        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        sortColumn = key;
        sortDirection = 'asc';
      }

      // Update header styling
      document.querySelectorAll('#tableHead th').forEach(t => {
        t.classList.remove('sorted-asc', 'sorted-desc');
      });
      th.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');

      // Sort the data
      currentData.sort((a, b) => {
        const sourceA = config.source === 'common' ? a.commonMetrics : a.uniqueMetrics;
        const sourceB = config.source === 'common' ? b.commonMetrics : b.uniqueMetrics;
        
        let valA = sourceA[key] ?? '';
        let valB = sourceB[key] ?? '';

        // Parse numeric values from strings like "18.636 KB" or "1.592ms"
        if (config.type !== 'string' && config.type !== 'predicate') {
          valA = parseNumericValue(valA);
          valB = parseNumericValue(valB);
        }

        // Compare
        if (valA < valB) return sortDirection === 'asc' ? -1 : 1;
        if (valA > valB) return sortDirection === 'asc' ? 1 : -1;
        return 0;
      });

      // Re-render table body
      renderTableBody(currentData);
    }

    // -----------------------------------------
    // Utility Functions
    // -----------------------------------------
    
    // Parse values like "18.636 KB", "1.592ms", "3.336K (3336)" into numbers
    function parseNumericValue(str) {
      if (typeof str === 'number') return str;
      if (!str || str === '-' || str === 'N/A') return 0;
      
      str = String(str).trim();
      
      // Handle format like "3.336K (3336)" - extract the number in parentheses
      const parenMatch = str.match(/\((\d+)\)/);
      if (parenMatch) {
        return parseInt(parenMatch[1]);
      }

      // Handle byte formats FIRST (before time, to avoid conflicts): "18.636 KB", "1.045 GB"
      // Order matters: check longer units first (TB, GB, MB, KB before B)
      const byteMatch = str.match(/([\d.]+)\s*(TB|GB|MB|KB|B)\b/i);
      if (byteMatch) {
        const value = parseFloat(byteMatch[1]);
        const unit = byteMatch[2].toUpperCase();
        const multipliers = { B: 1, KB: 1024, MB: 1024**2, GB: 1024**3, TB: 1024**4 };
        return value * (multipliers[unit] || 1);
      }

      // Handle time formats: "1.592ms", "103.060ms", "2s345ms", "26s134ms"
      // First try compound format like "26s134ms"
      const compoundTimeMatch = str.match(/(\d+)s(\d+)ms/i);
      if (compoundTimeMatch) {
        const seconds = parseInt(compoundTimeMatch[1]);
        const milliseconds = parseInt(compoundTimeMatch[2]);
        return seconds + (milliseconds / 1000);
      }
      
      // Simple time format
      const timeMatch = str.match(/([\d.]+)\s*(ns|us|ms|s|m|h)\b/i);
      if (timeMatch) {
        const value = parseFloat(timeMatch[1]);
        const unit = timeMatch[2].toLowerCase();
        const multipliers = { ns: 1e-9, us: 1e-6, ms: 1e-3, s: 1, m: 60, h: 3600 };
        return value * (multipliers[unit] || 1);
      }

      // Try to parse as plain number
      const num = parseFloat(str.replace(/,/g, ''));
      return isNaN(num) ? 0 : num;
    }

    // Sum a metric across all scans
    function sumMetric(scans, key, source) {
      return scans.reduce((sum, scan) => {
        const metrics = source === 'common' ? scan.commonMetrics : scan.uniqueMetrics;
        return sum + parseNumericValue(metrics[key]);
      }, 0);
    }

    // Format large numbers
    function formatNumber(num) {
      if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
      if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
      if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
      return num.toLocaleString();
    }

    // Format bytes
    function formatBytes(bytes) {
      if (bytes >= 1024**4) return (bytes / 1024**4).toFixed(2) + ' TB';
      if (bytes >= 1024**3) return (bytes / 1024**3).toFixed(2) + ' GB';
      if (bytes >= 1024**2) return (bytes / 1024**2).toFixed(2) + ' MB';
      if (bytes >= 1024) return (bytes / 1024).toFixed(2) + ' KB';
      return bytes.toFixed(2) + ' B';
    }

    // ========================================
    // TAB NAVIGATION
    // ========================================
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        // Update button states
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Show the selected tab panel
        const tabId = btn.dataset.tab;
        document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
        document.getElementById(`tab-${tabId}`).classList.add('active');
      });
    });

    // ========================================
    // QUERY COMPARISON
    // ========================================
    
    // Store loaded comparison data
    let compareData = {
      baseline: null,
      optimized: null
    };

    // Setup comparison drop zones
    function setupCompareDropZone(dropZoneId, fileInputId, type) {
      const dropZone = document.getElementById(dropZoneId);
      const fileInput = document.getElementById(fileInputId);

      dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('drag-over');
      });

      dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('drag-over');
      });

      dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('drag-over');
        const file = e.dataTransfer.files[0];
        if (file && file.name.endsWith('.json')) {
          loadCompareFile(file, type, dropZone);
        }
      });

      dropZone.addEventListener('click', () => fileInput.click());

      fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          loadCompareFile(file, type, dropZone);
        }
      });
    }

    // Load a comparison file
    function loadCompareFile(file, type, dropZone) {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        try {
          const json = JSON.parse(e.target.result);
          const query = json.Query;
          
          if (!query) {
            alert('Invalid query profile format');
            return;
          }

          // Extract data
          const summary = query.Summary || {};
          const execution = query.Execution || {};
          const scans = findConnectorScans(execution);

          compareData[type] = {
            summary,
            execution,
            scans,
            filename: file.name
          };

          // Update drop zone to show loaded state
          dropZone.classList.add('loaded');
          dropZone.innerHTML = `
            <h3>${type === 'baseline' ? 'üìä Baseline' : 'üöÄ Optimized'}</h3>
            <p class="loaded-info">‚úì ${file.name}</p>
            <p>${summary['Query ID'] || 'Unknown'}</p>
            <p>Duration: ${summary['Total'] || 'N/A'}</p>
          `;

          // Check if both files are loaded
          if (compareData.baseline && compareData.optimized) {
            renderComparison();
          }
        } catch (error) {
          console.error('Error parsing JSON:', error);
          alert('Error parsing JSON: ' + error.message);
        }
      };

      reader.readAsText(file);
    }

    // Render the comparison view
    function renderComparison() {
      const results = document.getElementById('compareResults');
      results.classList.add('visible');

      const baseline = compareData.baseline;
      const optimized = compareData.optimized;

      // Render query info
      document.getElementById('compareMetaBaseline').innerHTML = `
        <span>Query ID:</span><strong>${baseline.summary['Query ID'] || 'N/A'}</strong>
        <span>Duration:</span><strong>${baseline.summary['Total'] || 'N/A'}</strong>
      `;
      document.getElementById('compareMetaOptimized').innerHTML = `
        <span>Query ID:</span><strong>${optimized.summary['Query ID'] || 'N/A'}</strong>
        <span>Duration:</span><strong>${optimized.summary['Total'] || 'N/A'}</strong>
      `;

      // Memory comparison
      const memoryMetrics = [
        { key: 'QueryAllocatedMemoryUsage', label: 'Allocated Memory' },
        { key: 'QuerySumMemoryUsage', label: 'Sum Memory Usage' },
      ];
      renderCompareCards('compareMemoryCards', memoryMetrics, baseline.execution, optimized.execution, true);

      // Time comparison
      const timeMetrics = [
        { key: 'QueryCumulativeCpuTime', label: 'CPU Time' },
        { key: 'QueryCumulativeScanTime', label: 'Scan Time' },
        { key: 'QueryCumulativeOperatorTime', label: 'Operator Time' },
        { key: 'QueryCumulativeNetworkTime', label: 'Network Time' },
      ];
      renderCompareCards('compareTimeCards', timeMetrics, baseline.execution, optimized.execution, true);

      // Scan metrics comparison
      const scanCards = [
        { 
          label: 'Connector Scan Operators', 
          baseline: baseline.scans.length, 
          optimized: optimized.scans.length,
          lowerIsBetter: true
        },
        { 
          label: 'Total Bytes Read', 
          baseline: sumMetric(baseline.scans, 'BytesRead', 'unique'),
          optimized: sumMetric(optimized.scans, 'BytesRead', 'unique'),
          format: 'bytes',
          lowerIsBetter: true
        },
        { 
          label: 'Total Rows Scanned', 
          baseline: sumMetric(baseline.scans, 'RawRowsRead', 'unique'),
          optimized: sumMetric(optimized.scans, 'RawRowsRead', 'unique'),
          format: 'number',
          lowerIsBetter: true
        },
        { 
          label: 'Total Rows Read', 
          baseline: sumMetric(baseline.scans, 'RowsRead', 'unique'),
          optimized: sumMetric(optimized.scans, 'RowsRead', 'unique'),
          format: 'number',
          lowerIsBetter: true
        },
      ];
      renderCompareCardsCustom('compareScanCards', scanCards);
    }

    // Render comparison cards from execution object
    function renderCompareCards(containerId, metrics, baselineExec, optimizedExec, lowerIsBetter) {
      const container = document.getElementById(containerId);
      
      container.innerHTML = metrics.map(metric => {
        const baselineVal = baselineExec[metric.key] || 'N/A';
        const optimizedVal = optimizedExec[metric.key] || 'N/A';
        
        const baselineNum = parseNumericValue(baselineVal);
        const optimizedNum = parseNumericValue(optimizedVal);
        
        const change = baselineNum > 0 ? ((optimizedNum - baselineNum) / baselineNum) * 100 : 0;
        const improved = lowerIsBetter ? change < 0 : change > 0;
        const changeClass = Math.abs(change) < 1 ? 'neutral' : (improved ? 'improved' : 'regressed');
        const changeSymbol = change > 0 ? '+' : '';
        
        return `
          <div class="compare-card">
            <div class="compare-card-label">${metric.label}</div>
            <div class="compare-card-values">
              <div class="compare-value">
                <div class="compare-value-label">Baseline</div>
                <div class="compare-value-num baseline">${baselineVal}</div>
              </div>
              <div class="compare-value">
                <div class="compare-value-label">Optimized</div>
                <div class="compare-value-num optimized">${optimizedVal}</div>
              </div>
              <div class="compare-change">
                <div class="compare-change-pct ${changeClass}">${changeSymbol}${change.toFixed(1)}%</div>
                <div class="compare-change-label">${improved ? '‚úì Better' : (Math.abs(change) < 1 ? '‚âà Same' : '‚ö† Worse')}</div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    // Render comparison cards with custom values
    function renderCompareCardsCustom(containerId, cards) {
      const container = document.getElementById(containerId);
      
      container.innerHTML = cards.map(card => {
        const baselineNum = card.baseline;
        const optimizedNum = card.optimized;
        
        const baselineDisplay = card.format === 'bytes' ? formatBytes(baselineNum) : 
                                card.format === 'number' ? formatNumber(baselineNum) : baselineNum;
        const optimizedDisplay = card.format === 'bytes' ? formatBytes(optimizedNum) : 
                                 card.format === 'number' ? formatNumber(optimizedNum) : optimizedNum;
        
        const change = baselineNum > 0 ? ((optimizedNum - baselineNum) / baselineNum) * 100 : 0;
        const improved = card.lowerIsBetter ? change < 0 : change > 0;
        const changeClass = Math.abs(change) < 1 ? 'neutral' : (improved ? 'improved' : 'regressed');
        const changeSymbol = change > 0 ? '+' : '';
        
        return `
          <div class="compare-card">
            <div class="compare-card-label">${card.label}</div>
            <div class="compare-card-values">
              <div class="compare-value">
                <div class="compare-value-label">Baseline</div>
                <div class="compare-value-num baseline">${baselineDisplay}</div>
              </div>
              <div class="compare-value">
                <div class="compare-value-label">Optimized</div>
                <div class="compare-value-num optimized">${optimizedDisplay}</div>
              </div>
              <div class="compare-change">
                <div class="compare-change-pct ${changeClass}">${changeSymbol}${change.toFixed(1)}%</div>
                <div class="compare-change-label">${improved ? '‚úì Better' : (Math.abs(change) < 1 ? '‚âà Same' : '‚ö† Worse')}</div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    // Initialize comparison drop zones
    setupCompareDropZone('compareDropBaseline', 'compareFileBaseline', 'baseline');
    setupCompareDropZone('compareDropOptimized', 'compareFileOptimized', 'optimized');

    console.log('StarRocks Query Profile Analyzer loaded!');
  </script>
</body>
</html>

